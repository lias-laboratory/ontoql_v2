/*********************************************************************************
 * This file is part of MariusQL Project.
 * Copyright (C) 2014  LIAS - ENSMA
 *   Teleport 2 - 1 avenue Clement Ader
 *   BP 40109 - 86961 Futuroscope Chasseneuil Cedex - FRANCE
 * 
 * MariusQL is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MariusQL is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with MariusQL.  If not, see <http://www.gnu.org/licenses/>.
 **********************************************************************************/
package fr.ensma.lias.mariusql.engine;

import java.io.PrintStream;
import java.io.PrintWriter;
import java.io.StringReader;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import antlr.RecognitionException;
import antlr.TokenStream;
import antlr.collections.AST;
import fr.ensma.lias.mariusql.engine.antlr.MariusQLBaseParser;
import fr.ensma.lias.mariusql.engine.util.ASTPrinter;
import fr.ensma.lias.mariusql.engine.util.ASTUtil;
import fr.ensma.lias.mariusql.engine.util.ErrorCounter;
import fr.ensma.lias.mariusql.engine.util.ParseErrorHandler;
import fr.ensma.lias.mariusql.exception.NotYetImplementedException;

/**
 * Implements the semantic action methods defined in the MariusQL base parser to
 * keep the grammar source file a little cleaner. Extends the parser class
 * generated by ANTLR.
 * 
 * @author Mickael BARON
 * @author StÃ©phane JEAN
 */
public final class MariusQLParser extends MariusQLBaseParser {

	/**
	 * A logger for this class.
	 */
	private static Logger log = LoggerFactory.getLogger(MariusQLParser.class);

	/**
	 * An handler of errors.
	 */
	private ParseErrorHandler parseErrorHandler;

	/**
	 * A printer of Trees.
	 */
	private ASTPrinter printer = getASTPrinter();

	/**
	 * Get a printer of trees.
	 * 
	 * @return a printer of trees
	 */
	private static ASTPrinter getASTPrinter() {
		return new ASTPrinter(fr.ensma.lias.mariusql.engine.antlr.MariusQLTokenTypes.class);
	}

	/**
	 * Singleton method to get the instance of MariusQLParser.
	 * 
	 * @param mariusQL An MariusQL query to parse
	 * @return A parser for this query
	 */
	public static MariusQLParser getInstance(final String mariusql) {
		MariusQLLexer lexer = new MariusQLLexer(new StringReader(mariusql));
		return new MariusQLParser(lexer);
	}

	/**
	 * Internal constructor with a lexer.
	 * 
	 * @param lexer A lexer to get the tokens
	 */
	private MariusQLParser(final TokenStream lexer) {
		super(lexer);
		initialize();
	}

	/**
	 * @param e A RecognitionException
	 * @see antlr.Parser#reportError(antlr.RecognitionException)
	 */
	public void reportError(final RecognitionException e) {
		parseErrorHandler.reportError(e); // Use the delegate.
	}

	/**
	 * @param s An error message
	 * @see antlr.Parser#reportError(java.lang.String)
	 */
	public void reportError(final String s) {
		parseErrorHandler.reportError(s); // Use the delegate.
	}

	/**
	 * @param s An warning message
	 * @see antlr.Parser#reportWarning(java.lang.String)
	 */
	public void reportWarning(final String s) {
		parseErrorHandler.reportWarning(s);
	}

	/**
	 * Print a tree.
	 * 
	 * @param ast The root node of the tree
	 * @param out the print stream
	 */
	public void showAst(final AST ast, final PrintStream out) {
		showAst(ast, new PrintWriter(out));
	}

	/**
	 * Print a tree.
	 * 
	 * @param ast The root node of the tree
	 * @param pw  the print writter
	 */
	private void showAst(final AST ast, final PrintWriter pw) {
		printer.showAst(ast, pw);
	}

	/**
	 * Initialize the error handler.
	 */
	private void initialize() {
		// Initialize the error handling delegate.
		parseErrorHandler = new ErrorCounter();
	}

	/**
	 * Get an error handler.
	 * 
	 * @return An error handler
	 */
	public ParseErrorHandler getParseErrorHandler() {
		return parseErrorHandler;
	}

	/**
	 * Handle panic of the parser.
	 */
	public static void panic() {
		throw new NotYetImplementedException("Replace QueryException of Hibernate to another kind of exception.");
	}

	/**
	 * Post process equality expressions, clean up the subtree.
	 * 
	 * @param x The equality expression.
	 * @return AST - The clean sub-tree.
	 */
	public AST processEqualityExpression(final AST x) {
		AST res = x;

		if (x == null) {
			log.info("processEqualityExpression(): no expression to process!");
			return null;
		}

		int type = x.getType();
		if (type == EQ || type == NE) {
			boolean negated = type == NE;
			if (x.getNumberOfChildren() > 1) {
				AST a = x.getFirstChild();
				AST b = a.getNextSibling();
				if (b.getType() == OF) {
					res = createIsOfParent(x, b, negated);
				} else if (x.getNumberOfChildren() == 2) {

					// (EQ NULL b) => (IS_NULL b)
					if (a.getType() == NULL && b.getType() != NULL) {
						res = createIsNullParent(b, negated);
					} else if (b.getType() == NULL && a.getType() != NULL) {
						// (EQ a NULL) => (IS_NULL a)
						res = createIsNullParent(a, negated);
					}
				}

			}
		}

		return res;
	}

	/**
	 * Helper method for negated node. node to handle
	 * 
	 * @param negated true to negate this node
	 * @return the node handled
	 */
	private AST createIsOfParent(final AST isNode, final AST ofNode, final boolean negated) {
		int type = negated ? IS_NOT_OF : IS_OF;
		String text = negated ? "is not of" : "is of";
		AST instanceChild = isNode.getFirstChild();
		instanceChild.setNextSibling(ofNode.getNextSibling());
		isNode.setText(text);
		isNode.setType(type);
		return isNode;
	}

	/**
	 * Helper method for negated node.
	 * 
	 * @param node    node to handle
	 * @param negated true to negate this node
	 * @return the node handled
	 */
	private AST createIsNullParent(final AST node, final boolean negated) {
		node.setNextSibling(null);
		int type = negated ? IS_NOT_NULL : IS_NULL;
		String text = negated ? "is not null" : "is null";
		return ASTUtil.createParent(astFactory, type, text, node);
	}

	/**
	 * Returns an equivalent tree for (NOT (a relop b) ), for example:
	 * 
	 * (NOT (GT a b) ) =&gt; (LE a b) .
	 * 
	 * @param x The sub tree to transform, the parent is assumed to be NOT.
	 * @return AST - The equivalent sub-tree.
	 */
	public AST negateNode(final AST x) {
		switch (x.getType()) {
		case OR:
			x.setType(AND);
			x.setText("{and}");
			negateNode(x.getFirstChild());
			negateNode(x.getFirstChild().getNextSibling());
			return x;
		case AND:
			x.setType(OR);
			x.setText("{or}");
			negateNode(x.getFirstChild());
			negateNode(x.getFirstChild().getNextSibling());
			return x;
		case EQ:
			x.setType(NE);
			x.setText("{not}" + x.getText());
			return x; // (NOT (EQ a b) ) => (NE a b)
		case NE:
			x.setType(EQ);
			x.setText("{not}" + x.getText());
			return x; // (NOT (NE a b) ) => (EQ a b)
		case GT:
			x.setType(LE);
			x.setText("{not}" + x.getText());
			return x; // (NOT (GT a b) ) => (LE a b)
		case LT:
			x.setType(GE);
			x.setText("{not}" + x.getText());
			return x; // (NOT (LT a b) ) => (GE a b)
		case GE:
			x.setType(LT);
			x.setText("{not}" + x.getText());
			return x; // (NOT (GE a b) ) => (LT a b)
		case LE:
			x.setType(GT);
			x.setText("{not}" + x.getText());
			return x; // (NOT (LE a b) ) => (GT a b)
		case LIKE:
			x.setType(NOT_LIKE);
			x.setText("{not}" + x.getText());
			return x; // (NOT (LIKE a b) ) => (NOT_LIKE a b)
		case NOT_LIKE:
			x.setType(LIKE);
			x.setText("{not}" + x.getText());
			return x; // (NOT (NOT_LIKE a b) ) => (LIKE a b)
		case IS_NULL:
			x.setType(IS_NOT_NULL);
			x.setText("{not}" + x.getText());
			return x; // (NOT (IS_NULL a b) ) => (IS_NOT_NULL a b)
		case IS_NOT_NULL:
			x.setType(IS_NULL);
			x.setText("{not}" + x.getText());
			return x; // (NOT (IS_NOT_NULL a b) ) => (IS_NULL a b)
		case BETWEEN:
			x.setType(NOT_BETWEEN);
			x.setText("{not}" + x.getText());
			return x; // (NOT (BETWEEN a b) ) => (NOT_BETWEEN a b)
		case NOT_BETWEEN:
			x.setType(BETWEEN);
			x.setText("{not}" + x.getText());
			return x; // (NOT (NOT_BETWEEN a b) ) => (BETWEEN a b)
		/*
		 * This can never happen because this rule will always eliminate the child NOT.
		 * case NOT: return x.getFirstChild(); // (NOT (NOT x) ) => (x)
		 */

		default:
			return super.negateNode(x); // Just add a 'not' parent.
		}
	}
}
