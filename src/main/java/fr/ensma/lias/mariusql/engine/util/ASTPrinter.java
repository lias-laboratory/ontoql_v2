/*********************************************************************************
 * This file is part of MariusQL Project.
 * Copyright (C) 2014  LIAS - ENSMA
 *   Teleport 2 - 1 avenue Clement Ader
 *   BP 40109 - 86961 Futuroscope Chasseneuil Cedex - FRANCE
 * 
 * MariusQL is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MariusQL is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with MariusQL.  If not, see <http://www.gnu.org/licenses/>.
 **********************************************************************************/
package fr.ensma.lias.mariusql.engine.util;

import java.io.ByteArrayOutputStream;
import java.io.PrintStream;
import java.io.PrintWriter;
import java.lang.reflect.Field;
import java.lang.reflect.Modifier;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import antlr.collections.AST;
import fr.ensma.lias.mariusql.engine.tree.DisplayableNode;
import fr.ensma.lias.mariusql.util.StringHelper;

/**
 * An 'ASCII art' AST printer for debugging ANTLR grammars.
 *
 * @author Mickael BARON
 * @author St√©phane JEAN
 */
public class ASTPrinter {

	/**
	 * Map between token name and type.
	 */
	private Map<Object, String> tokenTypeNamesByTokenType;

	/**
	 * Class of the token.
	 */
	private Class<?> tokenTypeConstants;

	/**
	 * Do the class name of this token must be printed?
	 */
	private boolean showClassNames = true;

	/**
	 * Constructs an org.hibernate.hql.antlr.ASTPrinter, given the class that
	 * contains the token type constants (typically the '{grammar}TokenTypes'
	 * interface generated by ANTLR).
	 * 
	 * @param tokenTypeConstants The class with token type constants in it.
	 */
	public ASTPrinter(final Class<?> tokenTypeConstants) {
		this.tokenTypeConstants = tokenTypeConstants;
	}

	/**
	 * Returns true if the node class names will be displayed.
	 * 
	 * @return true if the node class names will be displayed.
	 */
	public final boolean isShowClassNames() {
		return showClassNames;
	}

	/**
	 * Enables or disables AST node class name display.
	 * 
	 * @param showClassNames true to enable class name display, false to disable
	 */
	public final void setShowClassNames(final boolean showClassNames) {
		this.showClassNames = showClassNames;
	}

	/**
	 * Prints the AST in 'ASCII art' tree form to the specified print stream.
	 * 
	 * @param ast The AST to print.
	 * @param out The print stream.
	 */
	private void showAst(final AST ast, final PrintStream out) {
		showAst(ast, new PrintWriter(out));
	}

	/**
	 * Prints the AST in 'ASCII art' tree form to the specified print writer.
	 * 
	 * @param ast The AST to print.
	 * @param pw  The print writer.
	 */
	public final void showAst(final AST ast, final PrintWriter pw) {
		List<AST> parents = new ArrayList<AST>();
		showAst(parents, pw, ast);
		pw.flush();
	}

	/**
	 * Prints the AST in 'ASCII art' tree form into a string.
	 * 
	 * @param ast    The AST to display.
	 * @param header The header for the display.
	 * @return The AST in 'ASCII art' form, as a string.
	 */
	public final String showAsString(final AST ast, final String header) {
		ByteArrayOutputStream baos = new ByteArrayOutputStream();
		PrintStream ps = new PrintStream(baos);
		ps.println(header);
		showAst(ast, ps);
		ps.flush();
		return new String(baos.toByteArray());
	}

	/**
	 * Get a single token type name in the specified set of token type constants
	 * (interface).
	 * 
	 * @param tokenTypeConstants Token type constants interface (e.g.
	 *                           HqlSqlTokenTypes.class).
	 * @param type               The token type ( typically from ast.getType() ).
	 * @return The token type name, *or* the integer value if the name could not be
	 *         found for some reason.
	 */
	public static final String getConstantName(final Class<?> tokenTypeConstants, final int type) {
		String tokenTypeName = null;
		if (tokenTypeConstants != null) {
			Field[] fields = tokenTypeConstants.getFields();
			for (int i = 0; i < fields.length; i++) {
				Field field = fields[i];
				tokenTypeName = getTokenTypeName(field, type, true);
				if (tokenTypeName != null) {
					break; // Stop if found.
				}
			} // for
		} // if type constants were provided

		// Use the integer value if no token type name was found
		if (tokenTypeName == null) {
			tokenTypeName = Integer.toString(type);
		}

		return tokenTypeName;
	}

	/**
	 * Get the name of this token.
	 * 
	 * @param field     field
	 * @param type      type of this node
	 * @param checkType true if we must check the type
	 * @return the name of this token
	 */
	private static String getTokenTypeName(final Field field, final int type, final boolean checkType) {
		if (Modifier.isStatic(field.getModifiers())) {
			try {
				Object value = field.get(null);
				if (!checkType) {
					return field.getName();
				} else if (value instanceof Integer) {
					Integer integer = (Integer) value;
					if (integer.intValue() == type) {
						return field.getName();
					}
				} // if value is an integer
			} catch (IllegalArgumentException ignore) {
			} catch (IllegalAccessException ignore) {
			}
		} // if the field is static
		return null;
	}

	/**
	 * Returns the token type name for the given token type.
	 * 
	 * @param type The token type.
	 * @return String - The token type name from the token type constant class, or
	 *         just the integer as a string if none exists.
	 */
	private String getTokenTypeName(final int type) {
		// If the class with the constants in it was not supplied, just
		// use the integer token type as the token type name.
		if (tokenTypeConstants == null) {
			return Integer.toString(type);
		}

		// Otherwise, create a type id -> name map from the class if it
		// hasn't already been created.
		if (tokenTypeNamesByTokenType == null) {
			Field[] fields = tokenTypeConstants.getFields();
			tokenTypeNamesByTokenType = new HashMap<Object, String>();
			String tokenTypeName = null;
			for (int i = 0; i < fields.length; i++) {
				Field field = fields[i];
				tokenTypeName = getTokenTypeName(field, type, false);
				if (tokenTypeName != null) {
					try {
						tokenTypeNamesByTokenType.put(field.get(null), field.getName());
					} catch (IllegalAccessException ignore) {
					}
				}
			} // for
		} // if the map hasn't been created.

		return (String) tokenTypeNamesByTokenType.get(new Integer(type));
	}

	/**
	 * Show the tree.
	 * 
	 * @param parents ?
	 * @param pw      ?
	 * @param ast     ?
	 */
	private void showAst(final List<AST> parents, final PrintWriter pw, final AST ast) {
		if (ast == null) {
			pw.println("AST is null!");
			return;
		}

		for (int i = 0; i < parents.size(); i++) {
			AST parent = (AST) parents.get(i);
			if (parent.getNextSibling() == null) {

				pw.print("   ");
			} else {
				pw.print(" | ");
			}
		}

		if (ast.getNextSibling() == null) {
			pw.print(" \\-");
		} else {
			pw.print(" +-");
		}

		showNode(pw, ast);

		List<AST> newParents = new ArrayList<AST>(parents);
		newParents.add(ast);
		for (AST child = ast.getFirstChild(); child != null; child = child.getNextSibling()) {
			showAst(newParents, pw, child);
		}
		newParents.clear();
	}

	/**
	 * Show a node.
	 * 
	 * @param pw  printer writter
	 * @param ast node to show
	 */
	private void showNode(final PrintWriter pw, final AST ast) {
		String s = nodeToString(ast, isShowClassNames());
		pw.println(s);
	}

	/**
	 * From node to String.
	 * 
	 * @param ast           node to convert
	 * @param showClassName true if we must display the class name
	 * @return the string result of this conversion
	 */
	public final String nodeToString(final AST ast, final boolean showClassName) {
		if (ast == null) {
			return "{null}";
		}
		StringBuilder buf = new StringBuilder();
		buf.append("[").append(getTokenTypeName(ast.getType())).append("] ");
		if (showClassName) {
			buf.append(StringHelper.unqualify(ast.getClass().getName())).append(": ");
		}

		buf.append("'");
		String text = ast.getText();
		appendEscapedMultibyteChars(text, buf);
		buf.append("'");
		if (ast instanceof DisplayableNode) {
			DisplayableNode displayableNode = (DisplayableNode) ast;
			// Add a space before the display text.
			buf.append(" ").append(displayableNode.getDisplayText());
		}
		String s = buf.toString();
		return s;
	}

	/**
	 * Append character.
	 * 
	 * @param text text
	 * @param buf  buffer
	 */
	public static final void appendEscapedMultibyteChars(final String text, final StringBuilder buf) {
		char[] chars = text.toCharArray();
		for (int i = 0; i < chars.length; i++) {
			char aChar = chars[i];
			if (aChar > 256) {
				buf.append("\\u");
				buf.append(Integer.toHexString(aChar));
			} else {
				buf.append(aChar);
			}
		}
	}

	/**
	 * Helper method.
	 * 
	 * @param text text
	 * @return the result
	 */
	public static final String escapeMultibyteChars(final String text) {
		StringBuilder buf = new StringBuilder();
		appendEscapedMultibyteChars(text, buf);
		return buf.toString();
	}
}